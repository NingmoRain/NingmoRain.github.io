---
layout: post
title: Optimizing Seed Selection for Fuzzing
categories: [论文记录]
description: Optimizing Seed Selection for Fuzzing论文记录
keywords: 论文记录
---



### [Optimizing Seed Selection for Fuzzing][]

#### 摘要

随机变异格式良好的程序输入或简单的模糊测试是一种高效且广泛使用的软件缺陷发现策略。除了让模糊测试器找到bug之外，在理解如何正确进行模糊测试的科学方面，几乎没有系统的努力。本文专注于如何从数学上形式化和推理模糊测试中的一个关键方面:如何最好地选择种子文件，以最大化在模糊测试过程中发现的bug总数。设计和评估了6种不同的算法，在亚马逊弹性计算云(EC2)上使用了650多个CPU天来提供真实数据。总的来说，我们在8个应用中发现了240个bug，这表明所选择的算法可以大大增加发现的bug数量。我们还表明，在Peach中发现的当前种子选择策略可能不会比随机选择种子更好。我们公开了我们的数据集和代码。

#### 1.介绍

软件测试很重要，Fuzzing 现在应用很多。Fuzzing 吸引人的一个原因是它相对简单和快速地开始工作。文章详细的区分不同的 Fuzzer ，只是从中挑选了一个典型的Fuzzer——BFF。为了评估种子选择策略，我们使用了流行的调度算法，如round-robin算法，以及the best possible (optimal) scheduling。

**我们通过为我们的系统创建一个  a hypothetical fuzzing testbed 来激励我们的研究，称为COVERSET。COVERSET定期监控互联网，下载程序，并对它们进行模糊测试。COVERSET的目标是在有限的时间或预算内最大限度地增加发现的错误数量。由于预算永远是有限的，我们希望做出明智的设计决策，尽可能地使用最优算法。**我们该如何着手建立这样一个系统呢？这里给出几个问题：

* 给定数百万、数十亿甚至数万亿的PDF文件，在模糊PDF查看器时应该使用哪些?
* 如何独立于模糊测试调度算法来衡量种子选择技术的质量?
* 我们是否可以为针对特定文件类型的程序的模糊测试提供一个同一个好的种子集?

我们的主要贡献是回答上述问题的技术：

* 我们形式化、实现并测试了一些现有的和新的种子选择算法
* We formalize the notion of ex post facto optimality seed selection and give the first strategy that provides an optimal algorithm even if the bugs found by different seeds are correlated.
* We develop evidence-driven techniques for identifying the quality of a seed selection strategy with respect to an optimal solution.
* 我们在Amazon EC2上使用超过650个CPU天进行了广泛的模糊实验，以获得代表性应用程序的实际情况。总的来说，我们在8个广泛使用的应用程序中发现了240个独特的错误，所有这些错误都在攻击面上(它们通常用于处理不受信任的输入，例如图像、网络文件等)，其中大多数是安全关键型的。

#### 2. Q1：种子选择

对每个程序进行足够时间的模糊处理以使其在所有种子文件中都有效，这在计算上是非常昂贵的。此外，种子文件集在模糊过程中引起的行为通常是重复的

 Peach建议使用执行的代码覆盖率作为种子选择策略，其直观的想法是，许多种子文件可能执行相同的代码块，而这些种子可能产生相同的错误。以前的工作已经显示了覆盖率和发现的bug之间的相关性，但还没有在许多方法之间进行比较研究，也没有研究如何衡量最优性。

**SCP（set cover problem）**：

* 假设当前存在一个种子文件的集合 $$\mathbb F=\{S_1,...,S_n\}$$
* 其中每个种子能够覆盖一定的代码 $$S_i=\{codeline\}$$
* 假设所有种子文件能够覆盖的代码行是$$X=\bigcup_{S\in \mathbb F} S$$
* 如果存在一个种子文件子集合 $$\mathbb C \subseteq \mathbb F$$，其覆盖的代码行是 $$\bigcup_{S\in \mathbb C} S=X$$
* 则称 $$\mathbb C$$ 为一个集合覆盖

**MSCP（minimal set cover problem）**：最小化集合覆盖$$\mathbb C$$ ，称为minset。minset可能是不唯一的，可能有多个满足条件的minset

**WMSCP（weighted minimal set cover problem）**：为每一个种子文件设置一个$$Cost()$$函数，寻找cost最小的minset。

MSCP和WMSCP都可以扩展可选参数k(分别形成k- scp和k- wscp)，指定返回解的最大大小，也就是寻找在指定大小的集合下，尽可能最大化覆盖，并且尽可能最小化cost。

##### 种子选择算法

* Peach Set：基于贪婪的集合覆盖

  <img src="https://ningmo.oss-cn-beijing.aliyuncs.com/img/image-20230207143810221.png" alt="image-20230207143810221" style="zoom: 50%;" />

* Random Set：随机选择k个种子文件

* Hot Set：每个种子文件单独测试五分钟，记录每个种子文件发现的bug数，取效果最好的k个种子文件

* Unweight Minset：选取k个种子文件，要求达到最高的覆盖范围

* Time Minset：选取k个种子文件，要求达到最高的覆盖范围，并且尽可能少的运行时间

* Size Minset：选取k个种子文件，要求达到最高的覆盖范围，并且尽可能小的文件大小

##### 具体问题

假设1：给定相同的大小参数k, MINSET算法比RANDOM SET算法能发现更多的bug。

假设2：计算给定应用程序和种子文件集的MINSET，然后开始模糊测试，比直接进行模糊测试能够发现更多的bug

假设3：minset在不同的程序上同时有效

假设4：使用minset测试能够比使用所有种子文件进行测试有更好的结果。

#### 3. RQ2：测量选择质量

在我们的方法中，主要的想法是衡量在特定种子子集中发现的bug的最佳情况。最佳情况提供了任意调度算法的上界，而不是特定调度算法的上界。

为了计算最优情况，对每一个种子文件 $$s_i$$​ 进行时间 t 的模糊测试，记录这个过程中能够发现的bug。利用模糊测试的结果计算事后的最优搜索策略，以最大限度地增加发现的bug数量。我们发现寻找最优调度算法本质上是一个整数规划问题，我们用整数线性规划(ILP)的方法来求解最优种子调度问题。

##### 形式化

* 假设模糊测试的时间限制是 $$t_{thres}$$
* 对每一个种子文件单独进行模糊测试，记录过程中发现的bug $$Fuzz(\{S_i\},t_{thres})=\{(b_1,S_i,t_1),...,(b_k,S_i,t_k)\}$$
  * $$b_k$$代表发现的第 k 个bug的内容
  * $$t_k$$代表发现第k个bug的时间戳

我们准备将具有固定时间预算的最优调度描述为ILP最大化问题

<img src="https://ningmo.oss-cn-beijing.aliyuncs.com/img/image-20230207150910037.png" alt="image-20230207150910037" style="zoom:50%;" />

约束(2)确保调度考虑发现的崩溃的顺序。特别地，如果找到了种子的第j个崩溃，则必须同时找到所有之前的崩溃。

约束(3)确保找到所有崩溃的时间不会超过我们的时间预算。

约束(4)表示，如果找到了一个崩溃，就找到了它对应的bug(基于stack-hash)

约束(5)保证，如果找到了一个bug，就至少找到了一个触发这个bug的崩溃。



除此之外，文章也尝试反向来使用求解，即对一个确定的调度 Round-Robin，能够反向选择最优的种子集合。

#### 4. Q3：种子文件可移植性

为单个应用P1预先计算好的种子集可能会耗费大量时间。COVERSET认为最小化总体成本的一种方法是找到一组“好的”种子，并在一个应用程序到另一个应用程序中重用它们。有几个理由相信这可能会奏效。

原因之一是大多数程序只依赖少数库来处理PDF、图像和文本。例如，如果应用程序P1和P2都链接到poppler PDF库，那么两个应用程序都可能在相同的输入上崩溃。然而，共享库通常很容易检测，而且这种情况可能没有意义。假设P1和P2都有独立的实现，例如P1使用poppler, P2使用GhostScript图形库。在类似的PDF上，P1和P2可能会崩溃的一个原因是，PDF标准中有一些难以正确实现的部分，因此它们都很可能出错。然而，人们可以推测出许多原因，这些应用程序中的bug是独立的。据我们所知，当通过模糊测试发现漏洞时，还没有系统的调查来解决这个问题。

#### 6. 实验

为了检查§2.2中介绍的假设的有效性，并根据COVERSET发现的错误评估整体性能，我们首先描述我们的实验装置。

**实验设置**

在Amazon EC2上的中型和小型虚拟机实例类型上运行。

所有虚拟机都运行相同的操作系统Debian Linux 7.4。

在整个实验中使用的CERT Basic Fuzzing Framework (BFF)。

收集的4,912,142个文件都是使用Bing API从互联网上自动爬取的

覆盖数据是通过使用英特尔PIN框架和标准的基于块的覆盖收集PIN工具的仪器应用程序收集的。

##### 6.1 建立 Ground Truth

为了测试MINSET假设，我们需要获得模糊测试的 Ground Truth，以解释每种可能的种子选择和调度。现在，我们将介绍选择目标应用程序、要模糊的文件和用于计算基本真相的参数的方法。

**目标程序**：选择了10个应用程序和5种流行的文件格式:PDF, MP3, GIF, JPG和PNG。我们的程序选择包括GUI和命令行应用程序、媒体查看器、播放器和转换器。我们手动将每个程序映射到它接受的文件格式，并形成13种不同的(应用程序、文件格式)进行模糊处理，如表2所示。我们为每种文件类型选择了至少两个不同的命令行来测试可移植性(假设3)。

**种子文件**：对于目标应用程序使用的每种文件类型，我们从种子文件数据库中随机抽取100个相应类型的种子文件。请注意，确定一个种子文件的Ground Truth需要12个小时，因此对我们的资源来说，找到所有4,912,142颗种子的真实值是不可能的

**模糊测试参数**：每个目标应用程序都被随机选择的100个正确文件类型的种子文件模糊了12个小时。因此，每个目标应用程序被模糊化1200小时。所有检测到的崩溃都记录了时间戳，并根据BFF的堆栈哈希算法进行分类。

**模糊测试结果**：BFF发现了2941个独特的崩溃。在一个应用程序mp3gain上发现了2,702个独特的崩溃。人工检查显示，崩溃是由于一个可利用的缓冲区溢出漏洞造成的，该漏洞破坏了堆栈，并混淆了BFF基于堆栈的唯一性算法。因此，在报告我们的结果时，我们将mp3gain中的2,702个唯一崩溃计算为一个。经过调整，BFF发现了240个漏洞。开发和试验更健壮、更有效、更准确的分类算法是一个开放的研究问题，也是未来工作的可能方向。

**模拟**：实验的参数允许我们在单个CPU上运行模拟和推理所有可能的种子选择(在应用程序的100个种子中)和调度算法，时间范围为12小时。我们的模拟器使用§3中的ILP公式来计算给定时间预算的最佳种子选择和调度。使用Ground Truth，我们可以在几分钟内运行模拟来评估长达一小时的模糊测试的性能。

我们使用模拟器并运行了一组实验来回答以下三个问题:

* 与RANDOM set(§6.2)相比，种子选择算法有多好(§6.2.1)?
* 我们可以在程序之间重用约简集吗(§6.3)?
* 我们的算法能否正确识别应用程序的文件类型(§6.4)?

##### 6.2 种子选择算法比随机抽样更好吗?

在种子选择算法上花费资源只有在选择的种子优于随机种子采样(random SET)时才有用。

因为只有Random Set是随机的，其他方法都是确定性的，所以没办法直接评判好坏，所以文章多次运行随机抽样，用好（坏）的概率来评价算法。实验有三种可能的结果:1)Random Set发现更多的bug, 2)Random Set发现更少的bug，或3)Random Set和竞争集合发现相同数量的bug。

我们对上述实验进行了13000次重复(每个元(应用程序、文件格式)1000次)，并测量了在采用最佳调度算法时每个事件的频率。然后我们使用RoundRobin作为调度算法，重复同样的实验。我们用频率除以样本数来计算概率。

![image-20230210094711858](https://ningmo.oss-cn-beijing.aliyuncs.com/img/image-20230210094711858.png)

第一种模式似乎在调度和选择算法中持续存在(基于图3)，在大多数实验中，随机集似乎表现得和选择算法一样好。这并不奇怪，因为我们的(应用程序，文件格式)组合(mplayer, MP3)， (eog, JPG)， (jpegtran, JPG)中有3/13(23%)根本不会崩溃。由于不需要寻找崩溃，任何算法都将是随机的。因此，为了将算法与RANDOM SET进行比较，我们将重点放在两种算法不同的情况下，即当两种算法没有找到相同数量的bug时，我们计算获胜的条件概率。

<img src="https://ningmo.oss-cn-beijing.aliyuncs.com/img/image-20230210095031034.png" alt="image-20230210095031034" style="zoom:50%;" />

除了PEACH SET和TIME MINSET算法的性能非常接近随机集外，我们的数据表明，种子选择算法采用的启发式算法比完全随机抽样的性能更好。因此，假设1似乎成立。然而，缺陷差异并不足以表明任何一种选择算法在统计显著性上严格更好。更长时间的模糊和/或获得更大种子池的基本真理是未来可能的方向，以证明种子选择算法严格地优于随机选择。

###### 哪种算法表现最好？

表2显示了最优调度算法下各算法计算的约简集的完整分解。第1列和第2列显示了我们正在分析的文件类型和程序，而第3列和第4列显示了在ground truth实验期间发现的崩溃总数和唯一错误(由堆栈散列识别)。 接下来的六列显示了每种种子选择算法的两个主要统计数据(在子列中):1)集合k (#S)的大小，以及2)用最优调度确定的bug (#B)的数量。允许所有集覆盖算法(PEACH set, UNWEIGHTED MINSET, TIME MINSET, SIZE MINSET)计算全覆盖，即根据需要选择尽可能多的文件来覆盖所有块。另外两种算法(RANDOM SET和HOT SET)被限制为k = 10的集合。

![image-20230210101430255](https://ningmo.oss-cn-beijing.aliyuncs.com/img/image-20230210101430255.png)

Reduced Set Size：表2反映了集合覆盖算法减少100个文件的原始数据集的能力。正如预期的那样，UNWEIGHTED MINSET在缩减能力方面是最好的，有278个文件可以获得全覆盖。TIME MINSET需要更多的文件(288)。MINSET和PEACH SET需要几乎两倍的文件来获得完全覆盖(分别为406和462)。

**Bug Finding**：PEACH SET算法发现最多的bug(295个)，其次是UNWEIGHTED MINSET(255个)，SIZE MINSET(182个)和TIME MINSET(170个)。当限制在大小不超过10的子集时，HOT SET和RANDOM SET发现的错误要少得多。我们再次强调，bug数量是在最优调度下测量的，因此缩减集的大小类似于选择算法的性能(当所有种子都被选中时，将发现最多的bug数量)。因此，为了比较种子集的错误发现能力，我们需要在集合大小k相同的情况下进行比较。

图4显示了所有的选择算法，以及它们如何根据发现的平均bug数量作为参数k(种子文件集的大小)的函数来执行。"X"符号表示每个算法实现完全覆盖之后的大小(在这一点之后，额外的文件被添加到选择算法的度量中排序)。在与RANDOM SET的比较中，UNWEIGHTED MINSET始终比其他种子选择算法表现更好。TIME MINSET和PEACH SET在最优调度下也最终收敛于UNWEIGHTED MINSET的性能，紧随其后的是随机。HOT SET表现最差，这表明花时间探索所有种子可能是浪费。我们还注意到，在获得完全覆盖(在20个种子文件)后，UNWEIGHTED MINSET的性能并没有以相同的速度提高——这表明添加不增加代码覆盖的新文件是没有好处的(即使有最佳调度)。

<img src="https://ningmo.oss-cn-beijing.aliyuncs.com/img/image-20230210101445370.png" alt="image-20230210101445370" style="zoom:50%;" />

我们执行了一个额外的模拟，其中所有的约简集运行与循环调度算法。图5显示了每个算法的性能作为参数k的函数。再次，我们注意到UNWEIGHTED MINSET优于其他算法。更有趣的是，我们还注意到UNWEIGHTED MINSET在获得全覆盖后的性能实际上有所下降。这表明，尽量减少种子的数量是重要的;在Round-Robin中添加更多种子似乎会损害所有算法的性能。

<img src="https://ningmo.oss-cn-beijing.aliyuncs.com/img/image-20230210101458711.png" alt="image-20230210101458711" style="zoom:50%;" />

 未加权MINSET表现最好。在我们的实验中，UNWEIGHTED MINSET在优化调度和RoundRobin调度方面都优于所有其他算法。这一实验证实了传统观点，即收集覆盖良好的种子才能成功羽化。更重要的是，它还表明，计算具有经过验证的竞争比(UNWEIGHTED MINSET)的近似值的最小覆盖比使用没有保证竞争比(PEACH SET)的算法更好。

###### 减少的种子集比完整的种子集好吗

假设4检验了使用简化数据集的前提。减少的种子会比完整的种子发现更多的bug吗?

在最优调度下，假设4为假。我们使用循环时间表来更现实地回答这个问题。

图5中的“X”符号显示了不同选择算法的无填充大小。对于这些大小，UNWEIGHTED MINSET算法平均发现4个错误，其他MINSET算法发现2.5到3个错误。用完整的集合进行模糊测试平均只发现1个独特的bug。

我们还通过查看一组种子中包含的平均种子质量来衡量一组种子的质量。我们的假设是，与完整的种子集相比，减少的集合提高了平均种子质量。为了衡量质量，我们计算了种子在模糊12小时后产生bug的概率，当种子从完整集或UNWEIGHTED MINSET中挑选时。实验结果如表3所示。未加权MINSET组有7个种子质量高于全组，3个种子质量低于全组。他们在剩下的三个案子上打成平手。

![image-20230210102102060](https://ningmo.oss-cn-beijing.aliyuncs.com/img/image-20230210102102060.png)

在实践中，用约简集进行模糊处理效率更高。在我们的两个实验中，未加权MINSET的表现优于完整集。我们的数据表明，使用种子选择技术有利于模糊测试

##### 6.3 简化集在程序间可重用吗?

然而，执行数据缩减可能是昂贵的计算;例如，所有集合覆盖算法都需要收集所有种子的覆盖信息。是花时间计算minset来模糊一个有效的减少集更有利可图，还是简单地模糊完整的种子集以满足完整的时间预算?换句话说，进行种子筛选值得吗?

我们通过展示部分数据集来回答这个问题。例如，我们的JPG包含530,727个从网络抓取的不同文件。我们的PIN工具需要55秒(基于表2中列出的10个应用程序的平均值)来计算单个种子的代码覆盖率。收集所有JPG文件的覆盖率统计信息需要368 cpu天。对于短于一年的模糊测试活动，没有足够的时间来计算代码覆盖率，更不用说找到比完整集更多的bug了。

上述结果表明，虽然种子选择技术有助于提高模糊的性能，但其收益可能不会超过成本。花费CPU一年的计算时间为每个需要模糊的新应用程序执行单独的种子选择是不切实际的，因此表明假设2不成立。

但是，为每个应用程序重新计算约简集可能没有必要。相反，我们可以为每种文件类型计算一个约简集。我们的直觉是，对于应用程序a是高质量的，对于应用程序b也应该是高质量的，假设它们接受相同的文件类型。因此，预先计算一次流行文件类型的缩减集，将允许我们立即选择一组高质量的种子文件来开始模糊。为了测试约简集的可移植性(假设3)，我们通过计算MINSET在程序间实现的代码覆盖率来衡量种子质量。

图6是总结我们结果的热图。底部的配置(x轴)表示所有计算的UNWEIGHTED minset，而左侧的配置(y轴)表示测试的配置。颜色越深表示所选的UNWEIGHTED MINSET获得更高的覆盖率。例如，如果我们选择pdf。mupdf MINSET在x轴上，我们可以看到它在y轴上的所有其他配置上的表现。例如，我们注意到pdf。mupdf MINSET在5个配置上表现明显更好:pdf。mupdf(预期的，因为这是我们计算MINSET的配置)，pdf。XPDF和pdf。Pdf2svg(这是意料之中的，因为这些应用程序也接受pdf)，有趣的是还有png。Convert和gif.convert。最初，我们很惊讶PDF MINSET会在转换上表现得这么好;事实证明，这个结果并不令人惊讶，因为convert也可以处理PDF文件。类似的模式可以用类似的方式解释——例如，对于mplayer, GIF minset比MP3 minset表现得更好，仅仅是因为mplayer可以渲染GIF图像。

 高覆盖率表示应用程序接受文件类型。例如，通过跟随动图的行。我们可以立即看到eog接受GIF、JPG和PNG文件，而不处理mp3或pdf文件。这与我们在文件类型推断算法(§6.4)中使用的模式完全相同。

覆盖范围在处理相同文件类型的应用程序之间传输。例如，我们清楚地看到PDF集群在所有PDF配置中形成，尽管在实现上有所不同。xpdf和pdf2svg都使用poppler库来处理pdf，而mupdf有一个完全独立的实现。然而，mupdf的MINSET在xpdf上表现良好，反之亦然。我们的数据显示，相似的集群出现在相同文件类型的配置中，这表明我们可以在接受相同文件类型的应用程序之间重用minset(假设3)。

我们的数据表明，减少的集合可以传递给程序解析相同的文件类型，就代码覆盖率而言。因此，对每种文件类型只计算一个简化集是必要的。

[Optimizing Seed Selection for Fuzzing]:https://ningmorain.github.io/files/sec14_seed_selection.pdf
