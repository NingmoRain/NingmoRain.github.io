#### 1.评价指标

* 黑盒：

  * unique bug：**发现缺陷能力强**的测试用例更应该被选择

  * 程序特征：拥有**独特程序特征**的测试用例更应该被选择
    * 文本程序特征：n-gram、PLBART
    * AST程序特征：graph embedding，InferCode
    * 控制流数据流程序特征：graph embedding

* 白盒：行覆盖率：能够**揭示更多compiler行为**的测试用例更应该被选择

  

* 辅助：在确保满足上述条件的前提下的优化方案

  * 执行时间

#### 2.选择策略

* ILP求解：采用线性规划的方式获得子集
* total贪婪分析：按指标排序，按顺序选择能增强指标的测试用例
* 增量贪婪分析：按指标增量排序，每次选择增量最大的测试用例
* 距离：让测试用例之间的距离最大化

#### 3.具体可实施方案

* unique bug
  * ILP：最小化总测试用例个数，确保 unique bug 覆盖
  * total贪婪（Hot Set）
  * 增量贪婪
  * 执行时间辅助
    * ILP：修改最小化目标为总特使用例执行时间
    * total贪婪：使用单位时间的指标进行排序
    * 增量贪婪(t-Min Set)：使用单位时间的指标增量排序
* 行/分支/函数 覆盖率
  * ILP：最小化总测试用例个数，确保覆盖
  * total贪婪 (Peach Set)
  * 增量贪婪 (Min Set)
  * 执行时间辅助，同上
    * ILP
    * total贪婪
    * 增量贪婪(t-Min Set)
* 程序特征，需要经过聚类，在类内选择测试用例
  * random：类内随机选择
  * 距离：选择与类外测试用例平均距离最远的
  * 执行时间辅助：选择类内执行时间最短的

#### 4.可应用的JVM方法

* classfuzz（关键字变异）
* classming（控制流变异）
* JavaTailor（代码片段合成）
* VECT（代码片段合成）:negative_squared_cross_mark::还要讲不能使用checksum，为什么不直接用JavaTailor

#### 5. 使用的数据集

* benchmark（小） : JavaTailor中选择的630个进行约简
* Hotspot-Test（中） :  整个Hotspot-Test中可执行的文件
* web（大） : 爬虫爬取 github 项目

#### 6.方案效果评估指标

* unique bug——RQ1、RQ2

* time cost——RQ3

#### 7.要回答的RQ

* RQ1：子集是否比全集更有效？
* RQ2：相同的子集是否可以应用于不同的测试方法？
* RQ3：花费大量时间进行白/灰盒分析是否值得？

#### 8. 遗留问题

* 先对测试用例进行约简，在对测试集进行约简