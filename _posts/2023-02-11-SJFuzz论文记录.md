---
layout: post
title: OptiMin论文记录
categories: [论文记录]
description: OptiMin论文记录
keywords: 论文记录

---

### [SJFuzz][]

#### 摘要

虽然Java虚拟机(JVM)在确保Java应用程序的正确执行方面发挥着至关重要的作用，但通过在JVM上生成和运行类文件来测试JVM可能相当具有挑战性。现有的技术，例如classFuzz和classMing，试图利用模糊和差异测试的力量，通过暴露不同JVM之间的执行结果差异(即JVM之间的差异)来处理JVM的复杂性，以进行测试分析。然而，他们采用的模糊器没有足够的指导，因为它们不包括设计良好的种子和突变子调度机制，使得差异测试基本上无效。为了解决这个问题，在本文中，我们提出了SJFuzz，这是第一个具有种子和突变调度机制的JVM模糊框架，用于自动JVM差异测试。总的来说，SJFuzz的目标是通过控制流突变器对类文件进行突变，以方便暴露jvm之间的差异。为此，SJFuzz根据差异和多样性指导为突变安排种子(类文件)。SJFuzz还为多样化的类文件生成调度变异器。为了评估SJFuzz，我们对多个具有代表性的真实JVM进行了广泛的研究，实验结果表明，SJFuzz在JVM间差异暴露和类文件多样性方面明显优于最先进的基于突变的JVM fuzzer。此外，SJFuzz成功报告了46个JVM错误，其中20个已被确认，16个已由JVM开发人员修复。

 #### 1. 介绍

在源代码文件被编译成字节码类文件之后，JVM首先利用类加载器按照加载、链接和初始化的严格顺序加载此类类文件。然后，JVM直接执行字节码，或者通过即时(JIT)或提前(AOT)编译器将加载的字节码转换为实际执行的机器代码，以实现优化目的。

现有的JVM模糊器未能利用代码覆盖作为种子调度指导，因为它们很难利用运行时覆盖信息进行模糊，因为JVM由于采用的机制(例如并行编译和按需垃圾收集[32])很可能在运行时造成不确定的覆盖。ClassFuzz只收集初始化jvm的覆盖信息，Classming甚至没有利用模糊覆盖。类似地，虽然最近证明了由代码覆盖率引导的调度突变子是有效的[49,62]，但现有的JVM模糊器在没有指导的情况下通过统一选择突变子而受到限制。

SJFuzz基于差异性和多样性两种指导原则对种子类文件进行调度。

* SJFuzz保留了一些类文件，这些类文件可以直接执行以引起jvm之间的差异，也可以用来生成要执行的变异体以引起jvm之间的差异，作为进一步变化的种子。
* 假设多样化的测试用例(类文件)生成可以反映代码覆盖率的增加，SJFuzz采用协同进化算法[9]对剩余的类文件进行过滤，增加类文件的多样性以供进一步变异。
* 通过迭代调度变异算子来增大种子类和变异类之间的整体距离。特别地，对于给定的种子类文件，SJFuzz估计每个变异算子的多样性期望，并选择一个变异算子来优化类文件多样性。

#### 2. Motivation

<img src="https://ningmo.oss-cn-beijing.aliyuncs.com/img/image-20230220101842476.png" alt="image-20230220101842476" style="zoom: 50%;" />

我们发现，对于示例类文件，Classming在通过统一选择的突变子迭代生成突变体后更新了新的种子类文件，并且未能在公平的时间限制下重现导致差异的执行路径。 这一事实表明，仅通过统一选择的变异体来采用相似的种子类文件可能会阻碍对导致差异的变异体的有效探索。此外，我们还观察到，虽然通常采用从一个根变异的类似种子类文件进行分类，导致计算资源的低效使用，但可以利用这些资源来探索其他有希望的种子类文件，例如，可以同时暴露多个差异[5,6]的种子类文件。这一事实也导致了对调度多个种子类文件的需求，而不是在一次运行中根据差异指导的潜力只调度一个。

#### 3. 方法细节

##### 3.1 控制流变异

直接沿用了classming中的控制流变异思路，这篇文章将重点放在了种子上，没有改变什么变异算子。

##### 3.2 种子调度

**Discrepancy-guided seed scheduling**：直观地说，如果运行类文件的突变体会导致jvm之间的差异，那么这种类文件可能会比其他类文件产生更多导致差异的变异体，因为它意味着与程序bug或漏洞的潜在联系。因此，这种类文件及其变种(如果有效，即成功地在至少一个被测JVM中运行，没有出现诸如验证器错误或崩溃等意外行为)被定义为主类文件，并被保留以供未来的迭代执行。

**Diversity-guided seed scheduling**：如果运行类文件的变异体不会立即导致jvm之间的差异，这并不意味着在未来的迭代执行中不会产生导致差异的变异体。换句话说，利用这样的类文件还可能会进一步暴露jvm之间的差异。在本文中，这种类文件被定义为可选的。请注意，差异测试通常为生成测试用例提供了很大的空间，这表明导致复杂jvm之间差异的类文件的总数可能相当有限。我们可以推断，可选类文件的数量可能大大超过主要类文件的数量。因此，SJFuzz需要对可选的类文件进行过滤，以保证模糊测试效率。

**filter the optional class file**：为了准确地反映类文件之间的细粒度差异，理想的度量应该反映它们逐条指令的比较。因此，我们采用给定类文件的执行指令，称其为EntryInstruction，作为代表指令，以有效地度量JVM类文件之间的多样性。在这里使用 edit distance来计算其相似性。

在此基础上，SJFuzz采用协同进化算法[9]，通过构造适应度函数反映个体与其他可选类文件的平均距离，对群体外的可选类文件进行高效评估。具体地，给出了算法2的适应度计算细节。对于每个可选类文件，SJFuzz计算它与其他可选类文件的总编辑距离。然后，计算平均编辑距离作为给定类文件的适应度得分。

##### 3.3 变异算子调度

一个简单的蒙特卡洛方法

#### 4. 评估

##### 4.1 benchmark

SJFuzz采用了来自7个开源项目的26个类文件作为种子类文件，用于基于变异的类文件生成。为了构建这样的基准，我们首先尝试收集最初用于评估分类的所有可用类文件，以接近公平的性能比较。结果，Eclipse、Jython、Fop和Sunflow因为它们的可用性而被选中，而其他的则导致陈旧的配置、JAR不兼容、不匹配的主声明等。此外，我们还采用Ant和Ivy (Apache项目[8]中两个流行的命令行应用程序)和JUnit来扩展基准测试的多样性。

[SJFuzz]:https://ningmorain.github.io/files/SJFuzz.pdf
